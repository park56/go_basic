Go 언어의 고루틴은 OS 쓰레드보다 가볍고 비동기적인 동시성 처리를 위해서 만들어진 실행 단위입니다. Go 런타임이 관리하는 경량 쓰레드라고 할 수 있습니다.

고루틴은 다음과 같은 특징을 가지고 있습니다.

가볍다. 고루틴은 OS 쓰레드보다 훨씬 가볍습니다. 초기 생성 시 2KB의 매우 작은 스택 크기만을 필요로 하며, 가지고 있는 레지스터도 프로그램 카운터(PC)와 스택 포인터(SP) 정도가 전부입니다.
비동기적이다. 고루틴은 서로 다른 쓰레드에서 실행될 수 있으므로, 서로 다른 고루틴 간의 실행은 비동기적으로 이루어집니다.
협동적이다. 고루틴은 협동적으로 스케줄링됩니다. 즉, 고루틴은 OS 쓰레드를 독점하지 않고, OS 쓰레드를 공유하여 사용합니다.
고루틴의 구현 원리는 다음과 같습니다.

고루틴을 생성하면, Go 런타임은 고루틴을 위한 스택을 할당합니다.
고루틴이 실행되면, Go 런타임은 고루틴을 하나의 OS 쓰레드에 할당합니다.
고루틴이 OS 쓰레드를 사용 중인 경우, Go 런타임은 다른 고루틴을 실행하기 위해 OS 쓰레드를 교체합니다.
고루틴이 종료되면, Go 런타임은 고루틴에 할당된 스택을 해제합니다.
고루틴은 Go 런타임에 포함된 Golang 스케줄러에 의해 스케줄링됩니다. Golang 스케줄러는 다음과 같은 방식으로 고루틴을 스케줄링합니다.

Golang 스케줄러는 모든 고루틴을 스택 크기, 실행 시간, 실행 상태 등을 기준으로 정렬합니다.
Golang 스케줄러는 가장 우선순위가 높은 고루틴을 하나의 OS 쓰레드에 할당합니다.
Golang 스케줄러는 OS 쓰레드를 고루틴에 할당한 후, 고루틴을 실행합니다.
Golang 스케줄러는 고루틴을 협동적으로 스케줄링합니다. 즉, 고루틴은 OS 쓰레드를 독점하지 않고, OS 쓰레드를 공유하여 사용합니다. 이렇게 하면, 고루틴 간의 실행이 비동기적으로 이루어질 수 있습니다.

고루틴은 Go 언어에서 프로그램의 동시성을 쉽게 구현할 수 있는 강력한 도구입니다. 고루틴을 사용하면, 다음과 같은 장점을 얻을 수 있습니다.

코드의 간결성과 가독성 향상
프로그램의 성능 향상
병렬 처리의 용이성
고루틴을 사용하면, 복잡한 동시성 처리를 보다 간결하고 효율적으로 구현할 수 있습니다.

--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

Go 언어의 고루틴은 Go 런타임에 포함된 Golang 스케줄러에 의해 관리됩니다. 고루틴은 OS 쓰레드보다 훨씬 가볍고, 2KB의 작은 스택 크기만을 필요로 합니다. 또한, 고루틴은 OS 쓰레드에 맵핑되어 실행되기 때문에, 고루틴이 많아도 OS 쓰레드의 수가 증가하지 않습니다.
고루틴의 스케줄링은 G-M-P 모델을 기반으로 합니다. G는 고루틴(Goroutine), M은 메모리(Memory), P는 쓰레드(Thread)를 의미합니다. 고루틴은 M에 의해 관리되고, M은 P에 의해 실행됩니다.
Go 런타임은 모든 고루틴을 G-M-P 모델에 따라 관리합니다. 고루틴이 생성되면, G-M-P 모델에 의해 M에 할당됩니다. M은 고루틴을 실행할 수 있는 P를 할당받습니다. 고루틴이 실행되면, P는 고루틴의 코드를 실행합니다.
고루틴이 시스템 콜을 호출하면, M은 고루틴을 대기 상태로 전환합니다. 고루틴이 대기 상태에 있으면, P는 다른 고루틴을 실행합니다. 시스템 콜이 완료되면, M은 고루틴을 실행 상태로 전환합니다.
고루틴이 종료되면, M은 고루틴을 메모리에서 제거합니다. P는 고루틴이 종료되었기 때문에, M에게 다른 고루틴을 할당해 줄 것을 요청합니다.

